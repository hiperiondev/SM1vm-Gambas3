' Gambas class file

Library "/opt/Hiperion/Desarrollos/workspace_SM1/SM1lib/Release/libSM1lib"
Extern sm1_init(ramSize As Integer, rsSize As Integer, dsSize As Integer) As Pointer Exec "init"
Extern sm1_step(word As Integer, vm As Pointer) As Integer Exec "step"
Extern sm1_mem_get(addr As Integer, vm As Pointer) As Integer Exec "mem_get"
Extern sm1_mem_put(addr As Integer, value As Integer, vm As Pointer) As Integer Exec "mem_put"
Extern sm1_read_vm(var As String, vm As Pointer) As Integer Exec "read_vm"
Extern sm1_write_vm(var As String, value As Integer, vm As Pointer) As Integer Exec "write_vm"
Extern sm1_read_ds(addr As Integer, vm As Pointer) As Integer Exec "read_ds"
Extern sm1_write_ds(addr As Integer, word As Integer, vm As Pointer) As Integer Exec "write_ds"
Extern sm1_read_rs(addr As Integer, vm As Pointer) As Integer Exec "read_rs"
Extern sm1_write_rs(addr As Integer, word As Integer, vm As Pointer) As Integer Exec "write_rs"
Static Public vm As Pointer
Public LineCounter As Long = 1
Public ret As Byte = 0
Public stopBtn As Boolean = False
Static result As Integer
Static loaded As Boolean
'Status flags
Const ST_SNDTN As Byte = &h01&
Const ST_RCVTN As Byte = &h02&
Const ST_RCVQT As Byte = &h04&
Const ST_IRQ As Byte = &h08&
Const ST_IMK As Byte = &h10&
'Operation types
Const OP_JMP As Short = &h0000&
Const OP_JZ As Short = &h2000&
Const OP_CALL As Short = &h4000&
Const OP_ALU As Short = &h6000&
Const OP_LIT As Long = &h8000&
'ALU flags
Const ALU_F_T2N As Byte = &h80&
Const ALU_F_T2R As Byte = &h40&
Const ALU_F_N2T As Byte = &h20&
Const ALU_F_R2P As Byte = &h10&

Public Sub Form_Open()
  Dim n As Integer
  Dim m As Integer
  loaded = False

  lMEM.text = "MEMORY"
  lDS.text = "DS"
  lRS.text = "RS"
  lPC.text = "PC"
  lT.text = "t"
  lDP.text = "DP"
  lRP.text = "RP"
  lT_EXT.text = "t_ext"
  lN_EXT.text = "n_ext"
  lSTATUS.text = "STATUS"
  bStart.text = "START"
  bStop.text = "STOP"
  bSTEP.text = "STEP"
  lIRQ.text = "IRQ"
  lRESULT.text = "RESULT"
  lWORD.text = "WORD"
  bLOAD.text = "LOAD"
  bRESET.text = "RESET"
  tbMEM.text = 0
  cbT2N.text = "T2N"
  cbT2R.text = "T2R"
  cbN2T.text = "N2T"
  cbR2P.text = "R2P"
  lADDR_LIT.text = "ADDR/LIT"
  tbRESULT.font.name = "Sans"
  tbRESULT.font.size = 7
  tbWORDstr.font.name = "Sans"
  tbWORDstr.font.size = 7
  lDELTAR.text = "DltR"
  lDELTAR.font.size = 7
  tbDELTAR.font.name = "Sans"
  tbDELTAR.font.size = 8
  lDELTAD.text = "DltD"
  lDELTAD.font.size = 7
  tbDELTAD.font.name = "Sans"
  tbDELTAD.font.size = 8
  lFILE.text = "FILE"
  lPROGRAM.text = "PROGRAM"
  taPROGRAM.font.name = "Sans"
  taPROGRAM.font.size = 7
  tbWORD.font.name = "Sans"
  tbWORD.font.size = 8
  tbADDR_LIT.font.name = "Sans"
  tbADDR_LIT.font.size = 8
  tbT.font.size = 8
  tbPC.font.size = 8
  tbDP.font.size = 8
  tbRP.font.size = 8
  tbT_EXT.font.size = 8
  tbN_EXT.font.size = 8
  tbSTATUS.font.size = 8
  cbSNDTN.text = "SNDTN"
  cbRCVTN.text = "RCVTN"
  cbRCVQT.text = "RCVQT"
  cbIRQ.text = "IRQ"
  cbIMK.text = "IMK"
  cbSNDTN.font.size = 7
  cbRCVTN.font.size = 7
  cbRCVQT.font.size = 7
  cbIRQ.font.size = 7
  cbIMK.font.size = 7
  tbFILE.font.size = 7
  tbMEM.font.size = 7
  taTERMINAL.font.size = 8
  bStop.Enabled = False
  bStart.Enabled = False
  bSTEP.enabled = False
  
  vm = sm1_init(16384, 32, 32)
  sm1_write_vm("pc", 0, vm)
  sm1_write_vm("dp", 0, vm)
  sm1_write_vm("rp", 0, vm)
  sm1_write_vm("t_ext", 0, vm)
  sm1_write_vm("n_ext", 0, vm)
  sm1_write_vm("status", 0, vm)
  
  ClearMemory
  
  tbPC.text = sm1_read_vm("pc", vm)
  tbT.text = sm1_read_vm("t", vm)
  tbDP.text = sm1_read_vm("dp", vm)
  tbRP.text = sm1_read_vm("rp", vm)
  tbT_EXT.text = sm1_read_vm("t_ext", vm)
  tbN_EXT.text = sm1_read_vm("n_ext", vm)
  tbSTATUS.text = sm1_read_vm("status", vm)
  sbIRQ.Value = 0

  With tMEM
   .Columns.Count = 128
   .Rows.Count = 128
   .font.name = "Sans"
   .font.size = 9   
  End With
  For n = 0 To 127
    tMEM.Columns[n].width = 6
  Next
  For n = 0 To 127
    tMEM.Rows[n].Height = 4
  Next
  For n = 0 To 127
    For m = 0 To 127
     tMEM[n, m].Background = Color.Blue
    Next
  Next
  
  With tDS
  .Columns.Count = 1
  .Rows.Count = 32
  .font.name = "Sans"
  .font.size = 9
  End With
  With tRS
  .Columns.Count = 1
  .Rows.Count = 32
  .font.name = "Sans"
  .font.size = 9
  End With
  With tSPOS
  .Columns.Count = 1
  .Rows.Count = 32
  .font.name = "Sans"
  .font.size = 8
  End With
  With tDP
  .Columns.Count = 1
  .Rows.Count = 32
  .font.name = "Sans"
  .font.size = 9
  End With
  With tRP
  .Columns.Count = 1
  .Rows.Count = 32
  .font.name = "Sans"
  .font.size = 9
  End With
  For n = 0 To 31
    tDS.Rows[n].Height = 15
    tRS.Rows[n].Height = 15
    tSPOS.Rows[n].Height = 15
    tRP.Rows[n].Height = 15
    tDP.Rows[n].Height = 15
    tSPOS[n, 0].text = n
  Next
  tDP[0, 0].Background = Color.blue
  tRP[0, 0].Background = Color.blue
End

Public Sub ClearMemory()
  Dim addr As Integer
  For addr = 0 To 31
   sm1_write_ds(addr, 0, vm)
   sm1_write_rs(addr, 0, vm)
  Next
End


Public Sub LoadFile(file As String)
  Dim hFile As File
  Dim word As Short
  Dim addr As Short
 
  addr = 0
  hFile = Open file For Input
  While Not Eof(hFile)
   word = Read #hFile As Short
   sm1_mem_put(addr, word, vm)
   addr = addr + 1
   If (addr > 16387) Then Break
  Wend
  MemColor
  RegistersRefresh
  StacksRefresh
  loaded = True
  bStart.Enabled = True
  bSTEP.enabled = True
End

Public Sub MemColor()
  Dim r As Byte
  Dim g As Byte
  Dim b As Byte
  Dim n As Integer
  Dim m As Integer
  Dim addr As Short
  Dim word As Short
  
  b = 128
  For n = 0 To 127
    For m = 0 To 127
      addr = (n * 128) + m
      word = sm1_mem_get(addr, vm)
      r = word
      g = Lsr(word, 8) 
     tMEM[n, m].Background = Color.RGB(r, g, b)
    Next
  Next
End

Public Sub RegistersRefresh()
  Dim st As Byte
  
  tbT.text = Hex$(CLong(sm1_read_vm("t", vm)) And &hffff&, 4)
  tbPC.text = Hex$(CLong(sm1_read_vm("pc", vm)) And &hffff&, 4)
  tbDP.text = Hex$(CLong(sm1_read_vm("dp", vm)) And &hffff&, 4)
  tbRP.text = Hex$(CLong(sm1_read_vm("rp", vm)) And &hffff&, 4)
  tbT_EXT.text = Hex$(CLong(sm1_read_vm("t_ext", vm)) And &hffff&, 4)
  tbN_EXT.text = Hex$(CLong(sm1_read_vm("n_ext", vm)) And &hffff&, 4)
  st = CByte(sm1_read_vm("status", vm))
  tbSTATUS.text = Hex$(CLong(st) And &hffff&, 4)
  
  If st And ST_SNDTN Then 
    cbSNDTN.value = True
    taTERMINAL &= Chr$(sm1_read_vm("t_ext", vm))
  End If
  If st And ST_RCVTN Then
   cbRCVTN.value = True
  Else
   cbRCVTN.value = False
  End If
  If st And ST_RCVQT Then
   cbRCVQT.value = True
  Else
   cbRCVQT.value = False
  End If
  If st And ST_IRQ Then
   cbIRQ.value = True
  Else
   cbIRQ.value = False
  End If
  If st And ST_IMK Then
   cbIMK.value = True
  Else
   cbIMK.value = False
  End If
End

Public Sub StacksRefresh()
  Dim n As Integer
  Dim rp As Integer
  Dim dp As Integer
  
  For n = 0 To 31
    tDS[n, 0].text = Hex$(CLong(sm1_read_ds(n, vm)) And &hffff&, 4)
    tRP[n, 0].Background = Color.Background
  Next
  For n = 0 To 31
    tRS[n, 0].text = Hex$(CLong(sm1_read_rs(n, vm)) And &hffff&, 4)
    tDP[n, 0].Background = Color.Background
  Next
  rp = sm1_read_vm("rp", vm)
  dp = sm1_read_vm("dp", vm)
  If (dp < 0 Or dp > 31 Or rp < 0 Or rp > 31) Then
    'Under/Over
  Else
    tRP[rp, 0].Background = Color.Blue
    tDP[dp, 0].Background = Color.Blue
  Endif
  
End

Public Sub Op(word As Integer, ret As Byte)
' ALU operations
Dim AluOP As String[] = [
  "ALU_OP_T",
  "ALU_OP_N",
  "ALU_OP_R",
  "ALU_OP_GET",
  "ALU_OP_PUT",
  "ALU_OP_DPLUS",
  "ALU_OP_DMUL",
  "ALU_OP_AND",
  "ALU_OP_OR",
  "ALU_OP_XOR",
  "ALU_OP_NEG",
  "ALU_OP_DEC",
  "ALU_OP_EQ0",
  "ALU_OP_EQ",
  "ALU_OP_UCMP",
  "ALU_OP_CMP",
  "ALU_OP_RSHIFT",
  "ALU_OP_LSHIFT",
  "ALU_OP_SP",
  "ALU_OP_RS",
  "ALU_OP_SETSP",
  "ALU_OP_SETRP",
  "ALU_OP_ST",
  "ALU_OP_TX",
  "ALU_OP_RX",
  "ALU_OP_UMOD",
  "ALU_OP_MOD",
  "ALU_OP_BYE",
  "ALU_OP_SETST"]

Dim delta As Short[] = ["0", "1", "-2", "-1"]

Dim ADDR_LIT As Short
If ret <> 0 Then
  taPROGRAM.text &= "[!]"
Else
  taPROGRAM.text &= "   "
Endif
If (word And OP_LIT) Then
  tbADDR_LIT.text = Hex$(CLong(ARG_LIT(word)) And &hffff&, 4)
  taPROGRAM.text &= Hex$(LineCounter, 4) & " OP_LIT " & Hex$(CLong(ARG_LIT(word)) And &hffff&, 4)
Else
  tbADDR_LIT.text = Hex$(CLong(ARG_OP(word)) And &hffff&, 4)
  Select Case OP_W(word)
    Case OP_JZ
      tbWORDstr.text = "OP_JZ"
      taPROGRAM.text &= Hex$(LineCounter, 4) & " OP_JZ " & Hex$(CLong(ARG_OP(word)) And &hffff&, 4)
    Case OP_JMP
      tbWORDstr.text = "OP_JMP"
      taPROGRAM.text &= Hex$(LineCounter, 4) & " OP_JMP " & Hex$(CLong(ARG_OP(word)) And &hffff&, 4)
    Case OP_CALL
      tbWORDstr.text = "OP_CALL"
      taPROGRAM.text &= Hex$(LineCounter, 4) & " OP_CALL " & Hex$(CLong(ARG_OP(word)) And &hffff&, 4)
    Case OP_ALU
      tbWORDstr.text = AluOP[ALU_OP(word)]
      taPROGRAM.text &= Hex$(LineCounter, 4) & " " & AluOP[ALU_OP(word)] & " ("
      If (word And ALU_F_R2P) Then
        cbR2P.value = True
        taPROGRAM.text = taPROGRAM.text & "R2P "
      Else
        cbR2P.value = False
      Endif
      If (word And ALU_F_N2T) Then
        cbN2T.value = True
        taPROGRAM.text = taPROGRAM.text & "N2T "
      Else
        cbN2T.value = False
      Endif
      If (word And ALU_F_T2R) Then
        cbT2R.value = True
        taPROGRAM.text = taPROGRAM.text & "T2R "
      Else
        cbT2R.value = False
      Endif
      If (word And ALU_F_T2N) Then
        cbT2N.value = True
        taPROGRAM.text = taPROGRAM.text & "T2N "
      Else
        cbT2N.value = False
      Endif
      tbDELTAR.text = delta[ALU_RS(word)]
      tbDELTAD.text = delta[ALU_DS(word)]
      taPROGRAM.text &= "RP:" & delta[ALU_RS(word)] & " DP:" & delta[ALU_DS(word)] & ")"
  End Select
Endif
taPROGRAM.text = taPROGRAM.text & "\n"
LineCounter = LineCounter + 1
End

Function OP_W(word As Short) As Short
  Return word And &he000&
End

Function ARG_OP(word As Short) As Short
  Return word And &h1fff&
End

Function ARG_LIT(word As Short) As Short
  Return word And &h7fff&
End

Function ALU_OP(word As Short) As Short
  Return Lsr((word And &h1f00&), 8) 
End

Function ALU_DS(word As Byte) As Byte
  Return word And &h03&
End

Function ALU_RS(word As Byte) As Byte
  Return Lsr(word, 2) And &h03& 
End

Function RET_COND(ret As Integer) As String
  Select Case ret
    Case 0
      Return "OK"
    Case 1
      Return "DS_UNDER"
    Case 2
      Return "DS_OVER"
    Case 3
      Return "RS_OVER"
    Case 4
      Return "RS_UNDER"
    Case 5
      Return "PC_OVER"
    Case 6
      Return "OP_UNKN"
    Case 7
      Return "ROM_WRITE"
    Case 8
      Return "MEM_OVER"
    Case 254
      Return "ERROR"
    Case 255
      Return "BYE"
    Case Else
      Return "???"
  End Select
End

'/////////////////////////////////////////////////////////////////////////

Public Sub bLoad_Click()
  load.Activate
  load.Raise
End

Public Sub sbIRQ_Click()
  If (sbIRQ.Value = True) Then 
    sbIRQ.Background = Color.Red
  Else
    sbIRQ.Background = Color.Green
  Endif
End


Public Sub bRESET_Click()
  sm1_write_vm("pc", 0, vm)
  sm1_write_vm("dp", 0, vm)
  sm1_write_vm("rp", 0, vm)
  RegistersRefresh
End

Public Sub bStep_Click()
  Dim word As Short
  
  If loaded = False Then 
    tbFILE.text = "LOAD FILE FIRST!!!"
    Return
  Endif
  word = sm1_mem_get(sm1_read_vm("pc", vm), vm)
  tbWORD.text = Hex$(CLong(word) And &hffff&, 4)
  ret = sm1_step(word, vm)
  tbRESULT.text = RET_COND(ret)
  op(word, ret)
  RegistersRefresh
  StacksRefresh
  MemColor
End

Public Sub bStart_Click()
bStop.Enabled = True
While ret = 0 And stopBtn = False
  bStep_Click
  Wait 0.1
Wend
stopBtn = False
bStop.Enabled = False
End

Public Sub bStop_Click()
stopBtn = True
End

Public Sub taTERMINAL_KeyPress()
  cbRCVTN.value = True
  sm1_write_vm("t_ext", Asc(Key.Text), vm)
  Print CByte(sm1_read_vm("status", vm))
  Print ST_RCVTN
  Print CByte(sm1_read_vm("status", vm)) Or ST_RCVTN
  sm1_write_vm("status", CByte(sm1_read_vm("status", vm)) Or ST_RCVTN, vm)
  
  
End
