' Gambas class file

 
 ' SM1vm GUI
 '
 ' License: GNU GPL V3
 '
 ' Created on: 23 may.2018
 ' Author: Emiliano Augusto Gonzalez(egonzalez.hiperion@gmail.com)

'//////////////////////////////////////// SM1vm ////////////////////////////////////////////
' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Change !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Library "/opt/Hiperion/Desarrollos/workspace_SM1/SM1lib/Release/libSM1lib"
' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

'VM api
Extern sm1_init(ramSize As Integer, rsSize As Integer, dsSize As Integer) As Pointer Exec "init"
Extern sm1_step(word As Integer, vm As Pointer) As Integer Exec "step"
Extern sm1_mem_get(addr As Integer, vm As Pointer) As Integer Exec "mem_get"
Extern sm1_mem_put(addr As Integer, value As Integer, vm As Pointer) As Integer Exec "mem_put"
Extern sm1_read_vm(var As String, vm As Pointer) As Integer Exec "read_vm"
Extern sm1_write_vm(var As String, value As Integer, vm As Pointer) As Integer Exec "write_vm"
Extern sm1_read_ds(addr As Integer, vm As Pointer) As Integer Exec "read_ds"
Extern sm1_write_ds(addr As Integer, word As Integer, vm As Pointer) As Integer Exec "write_ds"
Extern sm1_read_rs(addr As Integer, vm As Pointer) As Integer Exec "read_rs"
Extern sm1_write_rs(addr As Integer, word As Integer, vm As Pointer) As Integer Exec "write_rs"

'New VM pointer
Static Public vm As Pointer

'Delta DS/RS
Public delta As Short[] = [0, 1, -2, -1]

'Status flags
Const ST_SNDTN As Byte = &h01&
Const ST_RCVTN As Byte = &h02&
Const ST_RCVQT As Byte = &h04&
Const ST_IRQ As Byte = &h08&
Const ST_IMK As Byte = &h10&

'Operation types
Const OP_JMP As Short = &h0000&
Const OP_JZ As Short = &h2000&
Const OP_CALL As Short = &h4000&
Const OP_ALU As Short = &h6000&
Const OP_LIT As Long = &h8000&

'ALU flags
Const ALU_F_T2N As Byte = &h80&
Const ALU_F_T2R As Byte = &h40&
Const ALU_F_N2T As Byte = &h20&
Const ALU_F_R2P As Byte = &h10&
'//////////////////////////////////////// SM1vm END/////////////////////////////////////////

Public LineCounter As Long = 1
Public ret As Byte = 0
Public mRP As Integer = 0
Public mDP As Integer = 0
Public stopBtn As Boolean = False
Public file As String
Static loaded As Boolean



Public Sub Form_Open()
  Dim n As Integer
  Dim m As Integer
  loaded = False
  
  FMain.Title = "SM1 GUI"
  lMEM.text = "MEMORY"
  lDS.text = "DS"
  lRS.text = "RS"
  lPC.text = "PC"
  lT.text = "t"
  lDP.text = "DP"
  lRP.text = "RP"
  lT_EXT.text = "t_ext"
  lN_EXT.text = "n_ext"
  lSTATUS.text = "STATUS"
  bStart.text = "START"
  bStop.text = "STOP"
  bSTEP.text = "STEP"
  lRESULT.text = "RESULT"
  lWORD.text = "WORD"
  bLOAD.text = "LOAD"
  bRESET.text = "RESET"
  tbMEM.text = 0
  cbT2N.text = "T2N"
  cbT2R.text = "T2R"
  cbN2T.text = "N2T"
  cbR2P.text = "R2P"
  lADDR_LIT.text = "ADDR/LIT"
  tbRESULT.font.name = "Sans"
  tbRESULT.font.size = 7
  tbWORDstr.font.name = "Sans"
  tbWORDstr.font.size = 7
  lDELTAR.text = "DltR"
  lDELTAR.font.size = 7
  tbDELTAR.font.name = "Sans"
  tbDELTAR.font.size = 8
  lDELTAD.text = "DltD"
  lDELTAD.font.size = 7
  tbDELTAD.font.name = "Sans"
  tbDELTAD.font.size = 8
  lFILE.text = "FILE"
  lPROGRAM.text = "PROGRAM"
  taPROGRAM.font.name = "Sans"
  taPROGRAM.font.size = 7
  tbWORD.font.name = "Sans"
  tbWORD.font.size = 8
  tbADDR_LIT.font.name = "Sans"
  tbADDR_LIT.font.size = 8
  tbT.font.size = 8
  tbPC.font.size = 8
  tbDP.font.size = 8
  tbRP.font.size = 8
  tbT_EXT.font.size = 8
  tbN_EXT.font.size = 8
  tbSTATUS.font.size = 8
  cbSNDTN.text = "SNDTN"
  cbRCVTN.text = "RCVTN"
  cbRCVQT.text = "RCVQT"
  cbIRQ.text = "IRQ"
  cbIMK.text = "IMK"
  cbSNDTN.font.size = 7
  cbRCVTN.font.size = 7
  cbRCVQT.font.size = 7
  cbIRQ.font.size = 7
  cbIMK.font.size = 7
  tbFILE.font.size = 7
  tbMEM.font.size = 7
  taTERMINAL.font.size = 8
  bStop.Enabled = False
  bStart.Enabled = False
  bSTEP.enabled = False
  lMaxDP.font.size = 7
  tbMaxDP.font.size = 7
  lMaxRP.font.size = 7
  tbMaxRP.font.size = 7
  lMaxDP.text = "mDP"
  lMaxRP.text = "mRP"
  cbLOGPRG.font.size = 8
  cbLOGPRG.text = "LOGPRG"
  cbLOGSTK.font.size = 8
  cbLOGSTK.text = "LOGSTK"
  cbLOGMEM.font.size = 8
  cbLOGMEM.text = "LOGMEM"
  lramSize.text = "ram"
  lrsSize.text = "rsSize"
  ldsSize.text = "dsSize"
  lramSize.font.size = 7
  lrsSize.font.size = 7
  ldsSize.font.size = 7
  tbramSize.font.size = 7
  tbrsSize.font.size = 7
  tbdsSize.font.size = 7
  tbramSize.text = 32768
  tbrsSize.text = 32
  tbdsSize.text = 32
  
  cbLOGPRG.Enabled = False
  cbLOGSTK.enabled = False
  cbLOGMEM.enabled = False
  
  cbSNDTN.Enabled = False
  cbRCVTN.Enabled = False
  cbRCVQT.Enabled = False
  cbIRQ.Enabled = False
  cbIMK.Enabled = False

  With tMEM
   .Columns.Count = 128
   .Rows.Count = 128
   .font.name = "Sans"
   .font.size = 9
  End With
  For n = 0 To 127
    tMEM.Columns[n].width = 6
  Next
  For n = 0 To 127
    tMEM.Rows[n].Height = 4
  Next
  For n = 0 To 127
    For m = 0 To 127
     tMEM[n, m].Background = Color.Blue
    Next
  Next
  
  With tDS
  .Columns.Count = 1
  .Rows.Count = 32
  .font.name = "Sans"
  .font.size = 9
  End With
  With tRS
  .Columns.Count = 1
  .Rows.Count = 32
  .font.name = "Sans"
  .font.size = 9
  End With
  With tSPOS
  .Columns.Count = 1
  .Rows.Count = 32
  .font.name = "Sans"
  .font.size = 8
  End With
  With tDP
  .Columns.Count = 1
  .Rows.Count = 32
  .font.name = "Sans"
  .font.size = 9
  End With
  With tRP
  .Columns.Count = 1
  .Rows.Count = 32
  .font.name = "Sans"
  .font.size = 9
  End With
  For n = 0 To 31
    tDS.Rows[n].Height = 15
    tRS.Rows[n].Height = 15
    tSPOS.Rows[n].Height = 15
    tRP.Rows[n].Height = 15
    tDP.Rows[n].Height = 15
    tSPOS[n, 0].text = n
  Next
  tDP[0, 0].Background = Color.blue
  tRP[0, 0].Background = Color.blue
End

Public Sub ClearMemory()
  Dim addr As Integer
  For addr = 0 To Val(tbrsSize.text) - 1
   sm1_write_rs(addr, 0, vm)
  Next
  For addr = 0 To Val(tbdsSize.text) - 1 
   sm1_write_ds(addr, 0, vm)
  Next
  For addr = 0 To Val(tbramSize.text) - 1
    sm1_mem_put(addr, 0, vm)
  Next
End

Public Sub LoadFile()
  Dim hFile As File
  Dim word As Long
  Dim addr As Long
  tbramSize.Enabled = False
  tbrsSize.Enabled = False
  tbdsSize.Enabled = False
  
  vm = sm1_init(Val(tbramSize.text), Val(tbrsSize.text), Val(tbdsSize.text))
  
  cbSNDTN.Enabled = True
  cbRCVTN.Enabled = True
  cbRCVQT.Enabled = True
  cbIRQ.Enabled = True
  cbIMK.Enabled = True
  
  sm1_write_vm("pc", 0, vm)
  sm1_write_vm("dp", 0, vm)
  sm1_write_vm("rp", 0, vm)
  sm1_write_vm("t_ext", 0, vm)
  sm1_write_vm("n_ext", 0, vm)
  sm1_write_vm("status", 0, vm)
  ClearMemory

  addr = 0
  hFile = Open file For Input
  While (Not Eof(hFile)) And (addr < Val(tbramSize.text))
   word = Read #hFile As Short
   sm1_mem_put(addr, word, vm)
   addr = addr + 1
  Wend
  sm1_write_vm("pc", sm1_mem_get(0, vm), vm)
  MemColor
  RegistersRefresh
  StacksRefresh
  loaded = True
  bStart.Enabled = True
  bSTEP.enabled = True
  cbLOGPRG.Enabled = True
  cbLOGSTK.enabled = True
  cbLOGMEM.enabled = True
End

Public Sub MemColor()
  Dim r As Byte
  Dim g As Byte
  Dim b As Byte
  Dim n As Integer
  Dim m As Integer
  Dim addr As Short
  Dim word As Short
  
  b = 128
  For n = 0 To 127
    For m = 0 To 127
      addr = (n * 128) + m
      word = sm1_mem_get(addr, vm)
      r = word
      g = Lsr(word, 8) 
     tMEM[n, m].Background = Color.RGB(r, g, b)
    Next
  Next
End

Public Sub RegistersRefresh()
  Dim st As Byte
  Dim DP As Integer
  Dim RP As Integer
  
  tbT.text = Hex$(CLong(sm1_read_vm("t", vm)) And &hffff&, 4)
  tbPC.text = Hex$(CLong(sm1_read_vm("pc", vm)) And &hffff&, 4)
  DP = sm1_read_vm("dp", vm)
  tbDP.text = Hex$(CLong(DP) And &hffff&, 4)
  RP = sm1_read_vm("rp", vm)
  tbRP.text = Hex$(CLong(RP) And &hffff&, 4)
  tbT_EXT.text = Hex$(CLong(sm1_read_vm("t_ext", vm)) And &hffff&, 4)
  tbN_EXT.text = Hex$(CLong(sm1_read_vm("n_ext", vm)) And &hffff&, 4)
  st = CByte(sm1_read_vm("status", vm))
  tbSTATUS.text = Hex$(CLong(st) And &hffff&, 4)
  
  If mRP < RP Then mRP = RP
  If mDP < DP Then mDP = DP
  tbMaxDP.text = mDP
  tbMaxRP.text = mRP
  
  If st And ST_SNDTN Then 
    cbSNDTN.value = True
    taTERMINAL &= Chr$(sm1_read_vm("t_ext", vm))
  End If
  If st And ST_RCVTN Then
   cbRCVTN.value = True
  Else
   cbRCVTN.value = False
  End If
  If st And ST_RCVQT Then
   cbRCVQT.value = True
  Else
   cbRCVQT.value = False
  End If
  If st And ST_IRQ Then
   cbIRQ.value = True
  Else
   cbIRQ.value = False
  End If
  If st And ST_IMK Then
   cbIMK.value = True
  Else
   cbIMK.value = False
  End If
End

Public Sub StacksRefresh()
  Dim n As Integer
  Dim rp As Integer
  Dim dp As Integer
  
  For n = 0 To 31
    tDS[n, 0].text = Hex$(CLong(sm1_read_ds(n, vm)) And &hffff&, 4)
    tRP[n, 0].Background = Color.Background
  Next
  For n = 0 To 31
    tRS[n, 0].text = Hex$(CLong(sm1_read_rs(n, vm)) And &hffff&, 4)
    tDP[n, 0].Background = Color.Background
  Next
  rp = sm1_read_vm("rp", vm)
  dp = sm1_read_vm("dp", vm)
  If (dp < 0 Or dp > 31 Or rp < 0 Or rp > 31) Then
    'Under/Over
  Else
    tRP[rp, 0].Background = Color.Blue
    tDP[dp, 0].Background = Color.Blue
  Endif
End

Public Sub Op(word As Integer)
  Dim op_word As String = ""

  ' ALU operations
  Dim AluOP As String[] = [
  "ALU_OP_T",
  "ALU_OP_N",
  "ALU_OP_R",
  "ALU_OP_GET",
  "ALU_OP_PUT",
  "ALU_OP_DPLUS",
  "ALU_OP_DMUL",
  "ALU_OP_AND",
  "ALU_OP_OR",
  "ALU_OP_XOR",
  "ALU_OP_NEG",
  "ALU_OP_DEC",
  "ALU_OP_EQ0",
  "ALU_OP_EQ",
  "ALU_OP_UCMP",
  "ALU_OP_CMP",
  "ALU_OP_RSHIFT",
  "ALU_OP_LSHIFT",
  "ALU_OP_SP",
  "ALU_OP_RS",
  "ALU_OP_SETSP",
  "ALU_OP_SETRP",
  "ALU_OP_ST",
  "ALU_OP_TX",
  "ALU_OP_RX",
  "ALU_OP_UMOD",
  "ALU_OP_MOD",
  "ALU_OP_BYE",
  "ALU_OP_SETST"]

  If (word And OP_LIT) Then
    tbADDR_LIT.text = Hex$(CLong(ARG_LIT(word)) And &hffff&, 4)
    op_word &= Hex$(LineCounter, 4) & " OP_LIT " & Hex$(CLong(ARG_LIT(word)) And &hffff&, 4)
    tbWORDstr.text = "OP_LIT"
  Else
    tbADDR_LIT.text = Hex$(CLong(ARG_OP(word)) And &hffff&, 4)
    Select Case OP_W(word)
      Case OP_JZ
        tbWORDstr.text = "OP_JZ"
        op_word &= Hex$(LineCounter, 4) & " OP_JZ " & Hex$(CLong(ARG_OP(word)) And &hffff&, 4)
      Case OP_JMP
        tbWORDstr.text = "OP_JMP"
        op_word &= Hex$(LineCounter, 4) & " OP_JMP " & Hex$(CLong(ARG_OP(word)) And &hffff&, 4)
      Case OP_CALL
        tbWORDstr.text = "OP_CALL"
        op_word &= Hex$(LineCounter, 4) & " OP_CALL " & Hex$(CLong(ARG_OP(word)) And &hffff&, 4)
      Case OP_ALU
        tbWORDstr.text = AluOP[ALU_OP(word)]
        op_word &= Hex$(LineCounter, 4) & " " & AluOP[ALU_OP(word)] & " ("
        If (word And ALU_F_R2P) Then
          cbR2P.value = True
          op_word &= "R2P "
        Else
          cbR2P.value = False
        Endif
        If (word And ALU_F_N2T) Then
          cbN2T.value = True
          op_word &= "N2T "
        Else
          cbN2T.value = False
        Endif
        If (word And ALU_F_T2R) Then
          cbT2R.value = True
          op_word &= "T2R "
        Else
          cbT2R.value = False
        Endif
        If (word And ALU_F_T2N) Then
          cbT2N.value = True
          op_word &= "T2N "
        Else
          cbT2N.value = False
        Endif
        tbDELTAR.text = delta[ALU_RS(word)]
        tbDELTAD.text = delta[ALU_DS(word)]
        op_word &= "RP:" & delta[ALU_RS(word)] & " DP:" & delta[ALU_DS(word)] & ")"
    End Select
  Endif

  If ret <> 0 Then
    taPROGRAM.text &= "[!]"
  Else
    taPROGRAM.text &= "   "
  Endif
  taPROGRAM.text &= op_word & "\n"
  Log_(op_word)
  LineCounter = LineCounter + 1
End

Function OP_W(word As Short) As Short
  Return word And &he000&
End

Function ARG_OP(word As Short) As Short
  Return word And &h1fff&
End

Function ARG_LIT(word As Short) As Short
  Return word And &h7fff&
End

Function ALU_OP(word As Short) As Short
  Return Lsr((word And &h1f00&), 8) 
End

Function ALU_DS(word As Byte) As Byte
  Return word And &h03&
End

Function ALU_RS(word As Byte) As Byte
  Return Lsr(word, 2) And &h03& 
End

Function RET_COND() As String
  Select Case ret
    Case 0
      Return "OK"
    Case 1
      Return "DS_UNDER"
    Case 2
      Return "DS_OVER"
    Case 3
      Return "RS_OVER"
    Case 4
      Return "RS_UNDER"
    Case 5
      Return "PC_OVER"
    Case 6
      Return "OP_UNKN"
    Case 7
      Return "ROM_WRITE"
    Case 8
      Return "MEM_OVER"
    Case 254
      Return "ERROR"
    Case 255
      Return "BYE"
    Case Else
      Return "???"
  End Select
End

Public Sub Log_(op_word As String)
  Dim hFile As File
  Dim n As Byte

  If cbLOGPRG.value Then
     Try hFile = Open file & ".logprg" For Write Append
     If Error Then hFile = Open file & ".logprg" For Write Create
     Print #hFile, Trim$(op_word)
     Close hFile
  Endif
 
  If cbLOGSTK.value Then    
    Try hFile = Open file & ".logstk" For Write Append
    If Error Then hFile = Open file & ".logstk" For Write Create
    op_word = ""
    op_word &= Hex$(LineCounter, 4) & " RG[ "
    op_word &= "T:" & Hex$(CLong(sm1_read_vm("t", vm)) And &hffff&, 4) & " "
    op_word &= "PC:" & Hex$(CLong(sm1_read_vm("pc", vm)) And &hffff&, 4) & " "
    op_word &= "DP:" & Hex$(CLong(sm1_read_vm("dp", vm)) And &hffff&, 4) & " "
    op_word &= "RP:" & Hex$(CLong(sm1_read_vm("rp", vm)) And &hffff&, 4) & " "
    op_word &= "T_EXT:" & Hex$(CLong(sm1_read_vm("t_ext", vm)) And &hffff&, 4) & " "
    op_word &= "N_EXT:" & Hex$(CLong(sm1_read_vm("n_ext", vm)) And &hffff&, 4) & " "
    op_word &= "STATUS:" & Hex$(CLong(CByte(sm1_read_vm("status", vm))) And &hffff&, 4) & " "
    op_word &= "]\n     DS[ "
    For n = 0 To tbdsSize.text - 1
      op_word &= Hex$(CLong(sm1_read_ds(n, vm)) And &hffff&, 4) & " "
    Next
    op_word &= "]\n     RS[ "
    For n = 0 To tbrsSize.text - 1
      op_word &= Hex$(CLong(sm1_read_rs(n, vm)) And &hffff&, 4) & " "
    Next
    op_word &= "]"
  
    Print #hFile, op_word 
    Close hFile
  Endif

  If cbLOGMEM.value Then

  Endif
End

'/////////////////////////////////////////////////////////////////////////

Public Sub bLoad_Click()
  load.Activate
  load.Raise
End


Public Sub bRESET_Click()
  sm1_write_vm("pc", 0, vm)
  sm1_write_vm("dp", 0, vm)
  sm1_write_vm("rp", 0, vm)
  sm1_write_vm("status", 0, vm)
  RegistersRefresh
End

Public Sub bStep_Click()
  Dim word As Short
  word = sm1_mem_get(sm1_read_vm("pc", vm), vm)
  tbWORD.text = Hex$(CLong(word) And &hffff&, 4)
  ret = sm1_step(word, vm)
  tbRESULT.text = RET_COND()
  op(word)
  RegistersRefresh
  StacksRefresh
  MemColor
End

Public Sub bStart_Click()
  cbLOGPRG.Enabled = False
  cbLOGSTK.Enabled = False
  cbLOGMEM.Enabled = False
  bStop.Enabled = True
  While ret = 0 And stopBtn = False
    bStep_Click
    Wait 0.01
  Wend
  stopBtn = False
  bStop.Enabled = False
  cbLOGPRG.Enabled = True
  cbLOGSTK.Enabled = True
  cbLOGMEM.Enabled = True
End

Public Sub bStop_Click()
  stopBtn = True
End

Public Sub taTERMINAL_KeyPress()
  sm1_write_vm("t_ext", Asc(Key.Text), vm)
  sm1_write_vm("status", CByte(sm1_read_vm("status", vm)) Or ST_RCVTN, vm)
End

Public Sub cbIRQ_Click()
  sm1_write_vm("status", CByte(sm1_read_vm("status", vm)) Or ST_IRQ, vm)
End

